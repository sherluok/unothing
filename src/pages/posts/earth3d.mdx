# Earth Online
> 使用 WebGL 在浏览器中渲染地球

## 前言

本文的目标是从0开始在浏览器上渲染一个可交互的地球，整个过程不需要提前了解 WebGL API 的使用方法、线性代数、图形学和 GIS 相关的知识，因为这些都会在文中讲到。但是你需要提前掌握最基本的 Javascript 语法和浏览器运行环境的常识。
 
```
效果预览
```

你可以到 `https://github.com/sherluok/earth` 克隆本项目，跟随章节内容的进行对源代码进行修改。

- [第一章 WebGL API]()
- [第二章 着色器]()
  - [工作流程]()
  - [顶点着色器]()
  - [片元着色器]()
  - [正多面体细分]()
- [第三章 线性代数]()
  - [矩阵变换]()
    - [旋转]()
    - [缩放]()
    - [平移]()
  - [视图投影]()
    - [正交投影]()
    - [透视投影]()
  - [键鼠交互]()
- [第四章 GIS]()
  - [墨卡托投影]()


## 第一章 WebGL API

在浏览器中使用 WebGL 渲染图形大致分为以下几个步骤：
1. 创建或获取 Canvas 元素
2. 获取 WebGL 上下文（就在这一步处理不支持 WebGL 的浏览器）
3. 设置顶点着色器和片元着色器
4. 将顶点数据传递给顶点着色器
5. 顶点着色器按设置对传入的数据进行运算，得到每个顶点的颜色值
6. 片元着色器按设置对顶点着色器的运算结果进行运算或插值，得到每个像素的颜色值
7. 计算完所有像素后，组成图片显示到屏幕上

不要把你宝贵的时间花在记忆 WebGL 的每个 API 的使用方法，而是要完全理解它的工作流程，达到明白这些 API 为什么要设计成那种形态的程度。具体的使用方法，只需要在手边备上一本参考手册，或者到 MDN 上搜索相应的文档即可。

下面是一个 Demo，实现了以上7个步骤。这个 Demo 分为两部分，左边是代码的运行结果，右边是源代码编辑器。对，它是一个编辑器，你可以随意修改里面的代码并运行，还可以打开 Console 查看控制台输出。对了，它实际上是运行在一个 IFrame 里面的，所以如果你嫌弃它尺寸太小，可以在一个网页里独立打开。在你浏览文章的过程中，它的内容会跟随文章的内容进行变化，就像一个代码教学的专用 PPT，直到你看完了它涉及的内容，他就会自动消失。这是一个我专门为本文开发的一个叫做 [CodePlayer]() 的东西, 在后文中会经常出现。好了，废话不多说，让我们开始画一些简单的图形。

```
CodePlayer "渐变三角形"
```

<div style={{ background: '#fff', height: '50vh', boxShadow: '0 0 0 1px #0002', borderRadius: 8 }}>
  CodePlayer "渐变三角形"
</div>

首先获取 canvas 元素，并拿到 WebGL 上下文。然后编写着色器代码，编译并绑定到当前的 WebGL 上下文中。接着我们想象一个立体空间中的三角形，把它3个顶点的空间坐标传给顶点着色器进行运算。<span style={{ background: '#f004' }}>此次编写的顶点着色器很粗暴的将顶点位置原封不动的传递给了片元着色器</span>，只是顺带把任何顶点的颜色都设置成了黑色。最后片元着色器计算出了 canvas 所占屏幕区域所有像素点的颜色，我们就看到了一个黑色的三角形。聪明的你可能注意到了，我们传入的坐标点是以 canvas 的中心为原点，向右为 X 轴正向，向下为 Y 轴正向。虽然目前没有用到 Z 轴，但你可以提前了解到，从原点出发垂直于屏幕所在平面并指向你眼睛的方向是 Z 轴的正向。X 轴的范围是 -1 到 +1，即把 canvas 在横向的长度映射到了 `-1 ~ +1` 的范围中；Y 轴也是一样，把 canvas 在竖向的宽度映射到了 `-1 ~ +1` 的范围中；Z 轴虽然与 canvas 没有对应关系，因为 canvas 没有厚度，但它也有 `-1 ~ +1` 的范围。片元着色器在计算像素颜色的时候，会忽略所有不处于这个 `-1 ~ +1` 正方体盒子中的像素点。所以你明白为什么我们很鸡贼的把 canvas 的 width 和 height 设置成一样了吗？因为不这么做的话，你传入的坐标点会被映射到一个不符合预期的位置，看起来像是拉伸变形了 。